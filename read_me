13/07/23

-------------------------------------------

implementer correctement infile, outfile,heredoc (ptit probleme de boucle inf);

regler les problemes de heredoc;

implementer les signaux

implementer exec sans pipe

implementer built_in (les notres) dans pipe

checker les leaks/norme (normalement tout est deja ok jusqua parser) et les close

-------------------------------------------

Regler probleme expand here_doc quand : $$PAGER$$LW$$LESS$$end 

12/07/23

-------------------------------------------

gerer le cas de ! apres $ exemple =
									 echo "$!PAGER" = PAGER;

10/07/2023

--------------------------------------------
le here_doc est maintenant fonctionnel, parcontre quand fichier extremement volumineux on a pas tout, a voir

Need faire l'expand dans here_doc egalmeent, sinon le reste à l'air good;

07/07/2023

--------------------------------------------
on a un leaks dans ft_expand_space de 1bytes quand un malloc(qui ne petera jamais) pete,
je sais comment le regler mais en vrai cest mega chiant a faire faut qu'on voie si on le laisse ou
pas, il est vraiment perdu de ouf pour le trouver cest juste de la chatte

ft_expand_space : les deux malloc(la lst et la str) cest
la str tmp1 dans create expand qui est pas free mais voila le bordel pour la free faut restructurer toute la fonction
et j'ai galeré de ouf a faire un truc normé et qui marche mdr

still reachable: 1 bytes in 1 blocks

---------------------------------------------

-verifier si ca pose probleme plus tard(les nodes vides)
de faire : $lol(var inexistante) :
    : Minishell > $lol $lol

Redirections[0]:

___________________

Command[0]:

char[0] : ||
char[1] : ||


 PS = cest la fonction presente dans get_expand l.83 
 qui creer cette node vide(au cas ou besoin de patch):
 	if (env == NULL)
		replace_false_expand_quote(end);

---------------------------------------------

Je viens de voir ca sur la page du projet :

Ne pas interpréter de quotes (guillemets) non fermés ou de 
caractères spéciaux non demandés dans le sujet, 
tels que \ (le backslash) ou ; (le point-virgule).

le probleme cest que j'ai implanté la gestion du \ (le backslash) et
ca marche vraiment niquel, a voir si il faut que je l'enleve
ou si on peut le laisser, cest quand meme stylé ce que ça gere^^

---------------------------------------------

dans unset verifier comment on le gere quand il est censé pas  avoir d'env
voir à l'exec : 

neyks in ~/Bureau/42/cercle_4/Minishell on alex λ env -i unset lol
env: «unset»: Aucun fichier ou dossier de ce type

---------------------------------------------

surement gerer le cas des variables (ajouter une verif qui donne un bool is_readonly ou pas)
en lecture seul(readonly) dans le parsing de env, a voir
car par exemple export et unset ne doivent pas marcher quand cest appelé sur une var en readonly
mais yen a le bash marche quand meme cest bizarre

---------------------------------------------

Verifier la commande $< si on la parse comme il faut

---------------------------------------------

redir valable tant qu'elle existe, peut y en a voir x, on prend que la derniere en compte
et ça pour chaque pipe separement
